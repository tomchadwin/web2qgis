# -*- coding: utf-8 -*-
"""
/***************************************************************************
 leaflet
                                 A QGIS plugin
 Load a webmap directly into QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-05-11
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Tom Chadwin
        email                : tom.chadwin@nnpa.org.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from web2qgis.utils import getTempDir, getScript, getRGBA
from web2qgis.qgisWriter import addWMS, addXYZ, addVector, setExtent

L2Q_STYLES = {
    "weight": "outline_width",
    "color": "color_border",
    "fillColor": "color"
}

L2Q_TYPES = {
    "weight": "float",
    "color": "rgba",
    "fillColor": "rgba"
}

def detectLeaflet(mainframe):
    detectResult = mainframe.evaluateJavaScript("L.version")
    if detectResult is None:
        result = False
    else:
        result = True
    return result

def getLeafletMap(mainframe, iface):
    tempDir = getTempDir()
    scriptFolder = os.path.join(os.path.dirname(__file__), "js")

    parserScript = getScript(scriptFolder, "esprima.js")
    mainframe.evaluateJavaScript(parserScript)
    getMapScript = getScript(scriptFolder, "getLeafletMap.js")
    lyrs = mainframe.evaluateJavaScript(getMapScript)
    for count, lyr in enumerate(lyrs):
        if lyr[0] == "wms":
            addWMS(lyr[1], lyr[2], lyr[3], iface)
        elif lyr[0] == "xyz":
            addXYZ(lyr[1], lyr[2], iface)
        elif lyr[0] == "vector":
            style = getLeafletStyle(lyr[2])
            addVector(lyr[1], style, count, tempDir)
        else:
            print("Unsupported layer type")

    getLeafletView(scriptFolder, mainframe, iface)

def getLeafletStyle(leafletStyle):
    if "body" in leafletStyle:
        returnVal = getComplexStyle(leafletStyle)
        qgisStyle = getSymbol(returnVal)
    else:
        qgisStyle = getSymbol(leafletStyle)
    return qgisStyle

def getSymbol(leafletStyle):
    qgisStyle = {}
    for k, v in leafletStyle.items():
        if k in L2Q_STYLES:
            if L2Q_TYPES[k] == "rgba":
                value = getRGBA(v)
            else:
                value = str(v)
            qgisStyle[L2Q_STYLES[k]] = value
    qgisStyle["size_unit"] = "Pixel"
    qgisStyle["line_width_unit"] = "Pixel"
    qgisStyle["outline_width_unit"] = "Pixel"
    return qgisStyle

def getComplexStyle(leafletStyle):
    returnVal = walkAST(leafletStyle, {}, 0)
    return returnVal

def getLeafletView(scriptFolder, mainframe, iface):
    getExtentScript = getScript(scriptFolder, "getLeafletView.js")
    extent = mainframe.evaluateJavaScript(getExtentScript)
    xMin, yMin, xMax, yMax = extent.split(",")
    setExtent(xMin, yMin, xMax, yMax, iface)

def walkAST(node, returnVal, depth):
    if type(node) is list:
        depth = depth + 1
        for child in node:
            returnVal = walkAST(child, returnVal, depth)
        depth = depth - 1
    elif type(node) is dict:
        if node["type"] == "ReturnStatement":
            for k in node["argument"]["properties"]:
                returnVal[k["key"]["name"]] = k["value"]["value"]
        else:
            depth = depth + 1
            for k, v in node.items():
                returnVal = walkAST(v, returnVal, depth)
            depth = depth - 1
    return returnVal
